name: mobilecoin-build

env:
  DOCKER_ORG: jgreat

  # Fog authority certificate path
  FOG_AUTHORITY_ROOT_CA_CERT_PATH: /var/tmp/fog_authority_root_ca_cert.pem

  # Enclave signing cert paths
  ENCLAVE_SIGNING_KEY_PATH: /var/tmp/enclave_signing.pem
  CONSENSUS_ENCLAVE_PRIVKEY: /var/tmp/enclave_signing.pem
  LEDGER_ENCLAVE_PRIVKEY: /var/tmp/enclave_signing.pem
  VIEW_ENCLAVE_PRIVKEY: /var/tmp/enclave_signing.pem
  INGEST_ENCLAVE_PRIVKEY: /var/tmp/enclave_signing.pem
  FOG_REPORT_URL: fog://fog.demo.mobilecoin.com

  # CHART_RELEASE_NAME: 
  # CHART_PATH: ./chart


# Expected secrets.
# RANCHER_TOKEN
# DOCKERHUB_USERNAME
# DOCKERHUB_TOKEN

# Expected not-secret-secrets.
# RANCHER_URL
# STAGING_CLUSTER
# STAGING_NAMESPACE
# STAGING_VALUES
# PRODUCTION_CLUSTER
# PRODUCTION_NAMESPACE
# PRODUCTION_VALUES

on:
  push:
    # tags:
    # - 'v*'
    branches:
    - release-1.2.0-ci-2
  # pull_request: {}

jobs:
  build-cargo-hardware:
    runs-on: self-hosted
    container:
      image: jgreat/rust-sgx-base:0.0.7
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Cache build binaries
      id: artifact_cache
      uses: actions/cache@v2
      with:
        path: |
          build_artifacts
        # Key is a hash of all the .rs, .proto and Cargo.toml files.
        # if code changes, invalidate cache and rebuild
        key: ${{ runner.os }}-build-cargo-hardware-build-artifacts-${{ hashFiles('**/*.rs', '**/*.proto', '**/Cargo.toml') }}

    - name: Cache cargo packages
      # We don't need cargo packages if we already have binaries.
      if: steps.artifact_cache.outputs.cache-hit != 'true'
      uses: actions/cache@v2
      with:
        # rust-sgx-base changes RUSTUP_HOME and CARGO_HOME to workaround GHA overriding HOME
        # Key is a hash of all the Cargo.lock files. If lock files change, invalidate cache so build pulls fresh packages.
        path: |
          /opt/cargo/git
          /opt/cargo/registry/index
          /opt/cargo/registry/cache
        key: ${{ runner.os }}-build-cargo-hardware-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Write environment values
      env:
        ENCLAVE_SIGNING_KEY: ${{ secrets.ENCLAVE_SIGNING_KEY }}
        FOG_AUTHORITY_ROOT_CA_CERT: ${{ secrets.FOG_AUTHORITY_ROOT_CA_CERT }}
      run: |
        echo "${ENCLAVE_SIGNING_KEY}" > "${ENCLAVE_SIGNING_KEY_PATH}"
        echo "${FOG_AUTHORITY_ROOT_CA_CERT}" > "${FOG_AUTHORITY_ROOT_CA_CERT_PATH}"

    - name: Build Rust
      # Only build if we don't have a cached set of binaries.
      if: steps.artifact_cache.outputs.cache-hit != 'true'
      env:
        IAS_MODE: DEV
        SGX_MODE: HW
        RUST_BACKTRACE: full
        MOB_RELEASE: 1
      run: |
        cargo build --release \
          -p mc-consensus-service \
          -p mc-admin-http-gateway \
          -p mc-util-generate-sample-ledger \
          -p mc-util-grpc-admin-tool \
          -p mc-util-keyfile \
          -p mc-ledger-distribution \
          -p mc-ledger-migration \
          -p mc-ledger-from-archive \
          -p mc-mobilecoind \
          -p mc-watcher \
          -p mc-fog-ingest-server \
          -p mc-fog-ingest-client \
          -p mc-fog-view-server \
          -p mc-fog-report-server \
          -p mc-fog-sql-recovery-db \
          -p mc-fog-ledger-server \
          -p mc-fog-test-client \
          -p mc-fog-distribution \
          -p mc-util-grpc-token-generator

    - name: Copy artifacts to cache
      # Only copy if we don't have a cached set of binaries.
      if: steps.artifact_cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p build_artifacts
        find target/release -maxdepth 1 -executable -type f -exec cp "{}" build_artifacts/ \;
        find target/release -maxdepth 1 -name "*.signed.so" -exec cp "{}" build_artifacts/ \;

    - name: check artifacts
      run: |
        ls -alR build_artifacts

    - name: Cache sample_data
      id: sample_data_cache
      uses: actions/cache@v2
      with:
        path: |
          sample_data
        key: sample-data-build-cargo-hardware-${{ github.sha }}

    - name: Populate origin data
      if: steps.sample_data_cache.outputs.cache-hit != 'true'
      env:
        BIN_PATH: build_artifacts
      run: |
        docker/support/populate_origin_data.sh

    - name: check sample_data
      run: |
        ls -alR sample_data

  # docker:
  #   runs-on: self-hosted
  #   needs:
  #   - build-cargo-hardware
  #   strategy:
  #     matrix:
  #       image:
  #       - go-grpc-gateway
  #       - node_hw
  #       - mobilecoind
  #       - watcher
  #       - fogingest
  #       - fogreport
  #       - fogview
  #       - fog-ledger
  #       - fog-test-client
  #       - bootstrap-tools
  #   steps:
  #   - name: Checkout
  #     uses: actions/checkout@v2

  #   - name: Cache build binaries
  #     id: artifact_cache
  #     uses: actions/cache@v2
  #     with:
  #       path: |
  #         build_artifacts
  #       key: ${{ runner.os }}-build-cargo-hardware-build-artifacts-${{ hashFiles('**/*.rs', '**/*.proto', '**/Cargo.toml') }}

  #   - name: Cache sample_data
  #     id: sample_data_cache
  #     uses: actions/cache@v2
  #     with:
  #       path: |
  #         sample_data
  #       key: sample-data-build-cargo-hardware-${{ github.sha }}

  #   - name: Generate version metadata
  #     id: meta
  #     run: |
  #       .github/workflows/helpers/metadata.sh

  #   - name: Generate Docker Tags
  #     id: docker_meta
  #     uses: docker/metadata-action@v3
  #     with:
  #       images: ${{ env.DOCKER_ORG }}/${{ matrix.image }}
  #       tags: |
  #         type=raw,value=${{ steps.meta.outputs.tag }}

  #   - name: Set up Docker Buildx
  #     uses: docker/setup-buildx-action@v1

  #   - name: Login to DockerHub
  #     uses: docker/login-action@v1
  #     with:
  #       username: ${{ secrets.DOCKERHUB_USERNAME }}
  #       password: ${{ secrets.DOCKERHUB_TOKEN }}

  #   - name: Publish to DockerHub
  #     id: docker_publish_dockerhub
  #     uses: docker/build-push-action@v2
  #     with:
  #       build-args: |
  #         REPO_ORG=${{ env.DOCKER_ORG }}
  #         BIN_PATH=build_artifacts
  #       cache-from: type=gha
  #       cache-to: type=gha,mode=max
  #       context: .
  #       file: docker/Dockerfile.${{ matrix.image }}
  #       labels: ${{ steps.docker_meta.outputs.labels }}
  #       push: true
  #       tags: ${{ steps.docker_meta.outputs.tags }}

  # charts:
  #   runs-on: self-hosted
  #   needs:
  #   - docker
  #   strategy:
  #     # Updating the chart index can only be done by one process at a time.
  #     max-parallel: 1
  #     matrix:
  #       chart:
  #       - fog-ingest
  #       - fog-services
  #       - consensus-node
  #       - consensus-node-config
  #       - mobilecoind
  #       - mc-core-common-config
  #       - mc-core-dev-env-setup
  #   steps:
  #   - name: Checkout
  #     uses: actions/checkout@v2

  #   - name: Generate version metadata
  #     id: meta
  #     run: |
  #       .github/workflows/helpers/metadata.sh

  #   - name: Package and publish chart
  #     uses: ./.github/actions/helm
  #     with:
  #       action: s3-publish
  #       aws_access_key_id: ${{ secrets.CHARTS_AWS_ACCESS_KEY_ID }}
  #       aws_secret_access_key: ${{ secrets.CHARTS_AWS_SECRET_ACCESS_KEY }}
  #       aws_default_region: us-east-2
  #       chart_repo: s3://charts.mobilecoin.com
  #       chart_app_version: ${{ steps.meta.outputs.tag }}
  #       chart_version: ${{ steps.meta.outputs.tag }}
  #       chart_path: helm/${{ matrix.chart }}

  # deploy:
  #   runs-on: self-hosted
  #   needs:
  #   - charts
  #   steps:
  #   - name: Checkout
  #     uses: actions/checkout@v2

  #   - name: Generate version metadata
  #     id: meta
  #     run: |
  #       .github/workflows/helpers/metadata.sh

  #   - name: Mobilecoin Development Deploy (Dispatch)
  #     uses: aurelien-baudet/workflow-dispatch@v2.1.1
  #     with:
  #       workflow: mobilecoin-dev-deploy
  #       token: ${{ secrets.ACTIONS_TOKEN }}
  #       wait-for-completion: true
  #       wait-for-completion-timeout: 20m
  #       wait-for-completion-interval: 10s
  #       display-workflow-run-url-interval: 30s
  #       inputs: |
  #         {
  #           "cluster": "use secret",
  #           "namespace": "${{ steps.meta.outputs.branch }}",
  #           "delete": "true",
  #           "version": "0.0.0-release-1-2-0-ci.16.sha-0fb7a7ba"
  #         }

  # deploy-staging:
  #   if: github.ref == 'refs/heads/develop'
  #   needs: docker
  #   runs-on: ubuntu-latest
  #   container:
  #     image: alpine/helm
  #     options: --entrypoint /bin/sh
  #   env:
  #     RANCHER_URL: ${{ secrets.RANCHER_URL }}
  #     RANCHER_TOKEN: ${{ secrets.RANCHER_TOKEN }}
  #     RANCHER_CLUSTER: ${{ secrets.STAGING_CLUSTER }}
  #     RANCHER_CLUSTER_NAMESPACE: ${{ secrets.STAGING_NAMESPACE }}
  #     VALUES: ${{ secrets.STAGING_VALUES }}
  #     TAGS: ${{ needs.docker.outputs.tags }}
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v2
  #     - name: Deploy
  #       run: |
  #         apk add --no-cache bash curl jq
  #         .github/workflows/helpers/rancher_deploy.sh

  # deploy-production:
  #   if: startsWith(github.ref, 'refs/tags/')
  #   needs: docker
  #   runs-on: ubuntu-latest
  #   container:
  #     image: alpine/helm
  #     options: --entrypoint /bin/sh
  #   env:
  #     RANCHER_URL: ${{ secrets.RANCHER_URL }}
  #     RANCHER_TOKEN: ${{ secrets.RANCHER_TOKEN }}
  #     RANCHER_CLUSTER: ${{ secrets.PRODUCTION_CLUSTER }}
  #     RANCHER_CLUSTER_NAMESPACE: ${{ secrets.PRODUCTION_NAMESPACE }}
  #     VALUES: ${{ secrets.PRODUCTION_VALUES }}
  #     TAGS: ${{ needs.docker.outputs.tags }}
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v2
  #     - name: Deploy
  #       run: |
  #         apk add --no-cache bash curl jq
  #         .github/workflows/helpers/rancher_deploy.sh
